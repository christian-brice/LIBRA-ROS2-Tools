### Extended Kalman Filter config file (UNUSED) ###
ekf_filter_node:
    ros__parameters:
        # If you're having trouble, try setting this to true, and then echo the
        #   /diagnostics_agg topic to see if the node is unhappy with any
        #   settings or data.
        print_diagnostics: true

        # The frequency (in Hz) at which the filter will output a position
        #   estimate. Note that the filter will not begin computation until it
        #   receives at least one message from an input. It will then run
        #   continuously regardless of whether it receives more measurements.
        #
        frequency: 100  # default: 30
 
        # Both `ekf_localization_node` and `ukf_localization_node` use a 3D
        #   omnidirectional motion model. If this parameter is set to true, 3D
        #   information will NOT be used in the state estimate. Use this only
        #   if you are operating in a 2D environment and want to ignore the
        #   effect of small variations in the ground plane that may otherwise
        #   be detected by, for example, an IMU.
        #
        two_d_mode: false  # default: false
 
        # Whether to broadcast the transformation over the /tf topic.
        #
        publish_tf: true  # default: true
 
        # REP-105 (http://www.ros.org/reps/rep-0105.html) specifies four
        #   primary coordinate frames: "base_link", "odom", "map", and "earth".
        #   The "base_link" frame is affixed to the robot. Both "odom" and
        #   "map" are world-fixed frames. The robot's position in the "odom"
        #   frame will drift over time, but is accurate in the short term and
        #   should be continuous; thus, the "odom" frame is the best frame for
        #   executing local motion plans. While the "map" frame contains the
        #   most globally accurate position estimate for your robot, it is
        #   subject to discrete jumps, e.g., due to the fusion of GPS data or a
        #   correction from a map-based localization node. The "earth" frame is
        #   used to relate various map frames by giving them a common reference
        #   frame. `ekf_localization_node` and `ukf_localization_node` are not
        #   concerned with the "earth" frame.
        #
        # Here is how to use the following settings:
        #   1. Set `map_frame`, `odom_frame`, and `base_link_frame` to the
        #      appropriate frame names for your system.
        #       1a. If your system does not have a map_frame, just remove it,
        #           and make sure `world_frame` is the same as `odom_frame`.
        #   2. If you are fusing *continuous* position data (such as encoder
        #      odometry, visual odometry, or IMU data) set `world_frame` to
        #      your `odom_frame` value. Note: this is the default behavior for
        #      robot_localization's state estimation nodes.
        #   3. If you are fusing global *absolute* position data that is
        #      subject to discrete jumps (e.g., GPS or position updates from
        #      landmark observations), then:
        #       3a. Set `world_frame` to your `map_frame` value.
        #       3b. *BE 100% SURE* that something else is generating the
        #           `odom`->`base_link` transform. This can even be another
        #           state estimation node from robot_localization! Note,
        #           however, that instance should NOT fuse the global data.
        #
        #map_frame: map             # default: "map"
        odom_frame: camera_link     # default: "odom"
        base_link_frame: base_link  # default: "base_link"
        world_frame: camera_link    # default: value of `odom_frame`
 
        # The filter can accept any number of inputs from each input message
        #   type (nav_msgs/Odometry, geometry_msgs/PoseWithCovarianceStamped,
        #   geometry_msgs/TwistWithCovarianceStamped, sensor_msgs/Imu). To add
        #   an input, simply append the next number in the sequence to its
        #   "base" name, e.g., odom0, odom1... twist0, twist1... imu0, imu1
        #   imu2... etc. The value should be the *topic name*. These parameters
        #   obviously have no default values, and must be specified.
        #
        # Further, each sensor reading updates some/all of the filter's state.
        #   By specifying a `[sensor_name]_config` vector, you have greater
        #   control over which of its values are fed to the filter. The order
        #   of values is as follows:
        #
        #       [x_pos   , y_pos    , z_pos,
        #        roll    , pitch    , yaw,
        #        x_vel   , y_vel    , z_vel,
        #        roll_vel, pitch_vel, yaw_vel,
        #        x_accel , y_accel  , z_accel]
        #
        #   For example, if you have an odometry message as input, but only 
        #   want to use its Z position value, then set the entire vector to
        #   false except for the third entry.
        #
        # Of course, some message types don't provide all the state variables
        #   estimated by the filter (e.g., a TwistWithCovarianceStamped message
        #   has no pose information, so the first six values are meaningless).
        #   In such cases, the corresponding configuration values don't matter.
        #
        imu0: camera/camera/imu             # default: N/A
        imu0_config: [false, false, false,  # default: all false
                      false, false, false,
                      false, false, false,
                      true , true , true ,  # camera/gyro -> angular vel
                      true , true , true]   # camera/accel -> linear accel
